if (valid) {
coords <- str_split(location, ",")[[1]]
res <- fromJSON(GET(
paste0(
"https://maps.googleapis.com/maps/api/streetview/metadata?location=",
location, "&key=", Sys.getenv("GOOGLE_MAPS_API_KEY")
)
) %>% content("text"))
res$location$lat
} else {
NA
}
},
longitude = {
if (valid) {
coords <- str_split(location, ",")[[1]]
res <- fromJSON(GET(
paste0(
"https://maps.googleapis.com/maps/api/streetview/metadata?location=",
location, "&key=", Sys.getenv("GOOGLE_MAPS_API_KEY")
)
) %>% content("text"))
res$location$lng
} else {
NA
}
}
) %>%
ungroup() %>%
filter(valid == TRUE)%>%
mutate(seqnum=row_number())%>%
filter(seqnum<=5)
if (nrow(locations) < 5) {
stop("Less than 5 valid locations found")
}
write_csv(locations, paste0(output_location,"Round ",round_no,"/locations.csv"))
# leaflet(locations) %>%
#   addProviderTiles(providers$CartoDB.Positron) %>%
#   addCircleMarkers(~longitude_draft, ~latitude_draft, fillColor = "blue", fillOpacity = 1, color = "black", stroke = TRUE,weight = 2, radius = 5, label = ~paste("Lat:", latitude_draft, "Lon:", longitude_draft)) %>%
#   addCircleMarkers(~longitude, ~latitude, fillColor = "red", fillOpacity = 1, color = "black", stroke = TRUE,weight = 2, radius = 5, label = ~paste("Exact Lat:", latitude, "Exact Lon:", longitude))
camera_angles<-c("0","72","144","216","288")
for (i in 1:nrow(locations)){
for (j in 1:length(camera_angles)){
# Parameters
api_key <- Sys.getenv("GOOGLE_MAPS_API_KEY")
location <- locations$location[i] # Latitude,Longitude
size <- "2048x2048"                 # Image size in pixels
heading <- camera_angles[j]                    # Direction of the camera in degrees
pitch <- "0"                      # Angle of the camera
output_file <- paste0(output_location,"Round ",round_no,"/location_",i,"_image_",j,".jpg")  # Name of the output file
# Construct the URL
url <- paste0(
"https://maps.googleapis.com/maps/api/streetview?",
"size=", size, "&",
"location=", location, "&",
"heading=", heading, "&",
"pitch=", pitch, "&",
"source=outdoor", "&",
"key=", api_key
)
# Download and save the image
response <- GET(url, write_disk(output_file, overwrite = TRUE))
# Check if the download was successful
if (response$status_code == 200) {
message("Image downloaded successfully!")
} else {
message("Failed to download image: ", response$status_code)
}
Sys.sleep(1)
}
}
if (pano=="on"){
for (i in 1:nrow(locations)){
file_paths <- c(paste0(output_location,"Round ",round_no,"/location_",i,"_image_1.jpg"),
paste0(output_location,"Round ",round_no,"/location_",i,"_image_2.jpg"),
paste0(output_location,"Round ",round_no,"/location_",i,"_image_3.jpg"),
paste0(output_location,"Round ",round_no,"/location_",i,"_image_4.jpg"),
paste0(output_location,"Round ",round_no,"/location_",i,"_image_5.jpg"))
images <- lapply(file_paths, image_read)
stitched_image <- image_append(image_join(images), stack = FALSE)
image_write(stitched_image, paste0(output_location,"Round ",round_no,"/location_",i,"_pano.jpg"))
}
}
library(tibble)
library(dplyr)
library(readr)
library(sf)
library(httr)
library(jsonlite)
library(purrr)
library(tidyverse)
library(janitor)
library(googlesheets4)
library(stringr)
library(geosphere)
library(leaflet)
library(magick)
library(metro)
library(gtfstools)
city <- "NYC"        #DC or NYC
round_no <- 3
google_sheet_link<-"https://docs.google.com/spreadsheets/d/188wl-XhzJ0fz0TCU9zHMOKmARJes0_Is-VX1b9NZgAs/edit?usp=sharing"
pano<-"off" #on or off to save panorama pictures of locations
at_large_percent<-1
downtown_percent<-0
greater_central_percent<-0
metro_percent<-0
manhattan_percent<-0
brooklyn_percent<-0
queens_percent<-0
bronx_percent<-0
subway_percent<-1
code_base<-paste0("C:/Users/jwest/github/geoguessr_cities/",city)
output_location<-paste0("C:/Users/jwest/github/geoguessr_cities/",city,"/output/")
if (city=="DC"){
at_large<-at_large_percent
downtown<-downtown_percent+at_large
greater_central<-greater_central_percent+downtown
metro<-metro_percent+greater_central
if (metro != 1) {
stop("Error: Sum of boroughs does not equal 100%")
}
at_large_coords <- matrix(c(
-77.119419, 38.934718,
-77.040882, 38.995841,
-76.909394, 38.892852,
-77.029331, 38.799234,
-77.027054, 38.855403,
-77.059426, 38.899524,
-77.092116, 38.906666,
-77.119419, 38.934718
), ncol = 2, byrow = TRUE)
downtown_coords <- matrix(c(
-77.045444, 38.911450,
-77.003304, 38.896285,
-77.003261, 38.885795,
-77.033344, 38.884692,
-77.039652, 38.887867,
-77.047162, 38.884158,
-77.056432, 38.893812,
-77.056861, 38.902398,
-77.045444, 38.911450
), ncol = 2, byrow = TRUE)
greater_central_coords <- matrix(c(
-77.071324, 38.904877,
-77.071323, 38.942876,
-77.027723, 38.945969,
-77.000524, 38.931387,
-76.983436, 38.899866,
-76.988088, 38.877886,
-77.020513, 38.875749,
-77.050640, 38.886504,
-77.057420, 38.901337,
-77.071324, 38.904877
), ncol = 2, byrow = TRUE)
}
if (city=="NYC"){
manhattan<-manhattan_percent
brooklyn<-brooklyn_percent+manhattan
queens<-queens_percent+brooklyn
bronx<-bronx_percent+queens
subway<-subway_percent+bronx
if (subway != 1) {
stop("Error: Sum of boroughs does not equal 100%")
}
manhattan_coords <- matrix(c(
-74.013875, 40.700163,
-74.024023, 40.704360,
-74.014279, 40.755175,
-73.927928, 40.878489,
-73.910015, 40.872770,
-73.934220, 40.834756,
-73.933159, 40.808281,
-73.927902, 40.796740,
-73.942641, 40.782089,
-73.940642, 40.775750,
-73.970457, 40.742866,
-73.969927, 40.728005,
-73.975405, 40.710730,
-74.013875, 40.700163
), ncol = 2, byrow = TRUE)
brooklyn_coords <- matrix(c(
-73.962692, 40.737428,
-73.929043, 40.727534,
-73.921881, 40.709394,
-73.895402, 40.681704,
-73.868821, 40.694847,
-73.855515, 40.642089,
-73.911528, 40.577762,
-74.013005, 40.570018,
-74.013976, 40.583109,
-74.001595, 40.582741,
-74.006693, 40.596383,
-74.031212, 40.603387,
-74.045535, 40.620895,
-74.018345, 40.663263,
-74.021016, 40.679282,
-73.996496, 40.704684,
-73.971977, 40.709469,
-73.962692, 40.737428
), ncol = 2, byrow = TRUE)
queens_coords <- matrix(c(
-73.967564, 40.736458,
-73.931842, 40.779854,
-73.909949, 40.792220,
-73.888406, 40.781261,
-73.887799, 40.767105,
-73.873233, 40.771977,
-73.850899, 40.759014,
-73.855754, 40.781445,
-73.861581, 40.786224,
-73.837061, 40.801662,
-73.771879, 40.798630,
-73.755856, 40.768024,
-73.751608, 40.783926,
-73.701719, 40.752578,
-73.700263, 40.739427,
-73.707789, 40.728022,
-73.730123, 40.722135,
-73.725025, 40.652367,
-73.743839, 40.643618,
-73.821883, 40.666261,
-73.822597, 40.647909,
-73.853239, 40.643285,
-73.869289, 40.694845,
-73.896493, 40.682682,
-73.922375, 40.709145,
-73.928582, 40.728072,
-73.967564, 40.736458
), ncol = 2, byrow = TRUE)
bronx_coords <- matrix(c(
-73.910848, 40.915267,
-73.819450, 40.888649,
-73.790025, 40.804987,
-73.912296, 40.796159,
-73.928312, 40.802131,
-73.933776, 40.810322,
-73.934095, 40.834624,
-73.909793, 40.872164,
-73.925643, 40.878535,
-73.910848, 40.915267
), ncol = 2, byrow = TRUE)
if (subway_percent>0){
temp_file <- tempfile(fileext = ".zip")
download.file("http://web.mta.info/developers/data/nyct/subway/google_transit.zip", temp_file)
gtfs_data <- read_gtfs(temp_file)
}
}
locations_draft<-data.frame()
for (j in 1:10){
borough_picker<-runif(n=1)
if (city=="DC"){
borough <- case_when(
city == "DC" & borough_picker <= at_large ~ "At Large",
city == "DC" & borough_picker <= downtown ~ "Downtown",
city == "DC" & borough_picker <= greater_central ~ "Greater Central",
city == "DC" & borough_picker <= metro ~ "Metro"
)
}
if (city=="NYC"){
borough <- case_when(
city == "NYC" & borough_picker <= manhattan ~ "Manhattan",
city == "NYC" & borough_picker <= brooklyn ~ "Brooklyn",
city == "NYC" & borough_picker <= queens ~ "Queens",
city == "NYC" & borough_picker <= bronx ~ "Bronx",
city == "NYC" & borough_picker <= subway ~ "Subway"
)
}
if (borough == "At Large") {
polygon_coords<-at_large_coords
}
if (borough == "Downtown") {
polygon_coords<-downtown_coords
}
if (borough == "Metro") {
metro_station<-rail_stations(LineCode = NULL, api_key = wmata_key(Sys.getenv("WMATA_API_KEY")))%>%
filter(State=="DC" & StationName!="Friendship Heights" & StationName!="Deanwood" & StationName!="Takoma")%>%
select(StationName,Lat,Lon)%>%
distinct()%>%
mutate(rand=runif(n()))%>%
filter(rand==min(rand))
# Extract latitude and longitude from the dataframe
lat <- metro_station$Lat
lon <- metro_station$Lon
# Function to calculate the new coordinates given distance and bearing
get_new_coords <- function(lat, lon, distance_ft, bearing) {
distance_m <- distance_ft * 0.3048 # Convert feet to meters
dest_point <- destPoint(c(lon, lat), b = bearing, d = distance_m)
return(dest_point)
}
# Calculate the new coordinates for the 4 points
nw_point <- get_new_coords(lat, lon, 100, 315) # Northwest (bearing 315 degrees)
ne_point <- get_new_coords(lat, lon, 100, 45)  # Northeast (bearing 45 degrees)
se_point <- get_new_coords(lat, lon, 100, 135) # Southeast (bearing 135 degrees)
sw_point <- get_new_coords(lat, lon, 100, 225) # Southwest (bearing 225 degrees)
# Create the matrix with the coordinates
metro_coords <- matrix(c(
nw_point[1], nw_point[2],
ne_point[1], ne_point[2],
se_point[1], se_point[2],
sw_point[1], sw_point[2],
nw_point[1], nw_point[2] # Close the loop
), ncol = 2, byrow = TRUE)
polygon_coords<-metro_coords
}
if (borough == "Manhattan") {
polygon_coords<-manhattan_coords
}
if (borough == "Brooklyn") {
polygon_coords<-brooklyn_coords
}
if (borough == "Queens") {
polygon_coords<-queens_coords
}
if (borough == "Bronx") {
polygon_coords<-bronx_coords
}
if (borough == "Subway") {
subway_station <- gtfs_data$stops%>%
filter(location_type==1)%>%
filter(stop_lon>-74.051977)%>%
select(stop_name,Lon=stop_lon,Lat=stop_lat)%>%
distinct()%>%
mutate(rand=runif(n()))%>%
filter(rand==min(rand))
# Extract latitude and longitude from the dataframe
lat <- subway_station$Lat
lon <- subway_station$Lon
# Function to calculate the new coordinates given distance and bearing
get_new_coords <- function(lat, lon, distance_ft, bearing) {
distance_m <- distance_ft * 0.3048 # Convert feet to meters
dest_point <- destPoint(c(lon, lat), b = bearing, d = distance_m)
return(dest_point)
}
# Calculate the new coordinates for the 4 points
nw_point <- get_new_coords(lat, lon, 100, 315) # Northwest (bearing 315 degrees)
ne_point <- get_new_coords(lat, lon, 100, 45)  # Northeast (bearing 45 degrees)
se_point <- get_new_coords(lat, lon, 100, 135) # Southeast (bearing 135 degrees)
sw_point <- get_new_coords(lat, lon, 100, 225) # Southwest (bearing 225 degrees)
# Create the matrix with the coordinates
subway_coords <- matrix(c(
nw_point[1], nw_point[2],
ne_point[1], ne_point[2],
se_point[1], se_point[2],
sw_point[1], sw_point[2],
nw_point[1], nw_point[2] # Close the loop
), ncol = 2, byrow = TRUE)
polygon_coords<-subway_coords
}
# Create an sf polygon
polygon_sf <- st_sfc(st_polygon(list(polygon_coords)), crs = 4326)
# Generate random points within the polygon
generate_random_points <- function(polygon, n = 1) {
bbox <- st_bbox(polygon)
points <- tibble(
lon = runif(n * 5, bbox["xmin"], bbox["xmax"]), # Generate extra points for filtering
lat = runif(n * 5, bbox["ymin"], bbox["ymax"])
) %>%
st_as_sf(coords = c("lon", "lat"), crs = 4326)
points_within <- points[st_intersects(points, polygon, sparse = FALSE), ]
if (nrow(points_within) < n) {
# Generate more points if needed
rbind(points_within, generate_random_points(polygon, n - nrow(points_within)))
} else {
points_within[1:n, ]
}
}
# Convert to dataframe with latitude and longitude
location_single <- st_coordinates(generate_random_points(polygon_sf, n = 1)) %>%
as_tibble() %>%
rename(longitude_draft = X, latitude_draft = Y)%>%
mutate(location=paste0(latitude_draft,",",longitude_draft),
borough=borough)
locations_draft<-bind_rows(locations_draft, location_single)
}
locations <- locations_draft %>%
rowwise() %>%
mutate(
valid = {
coords <- str_split(location, ",")[[1]]
lat <- coords[1]
lng <- coords[2]
res <- fromJSON(GET(
paste0(
"https://maps.googleapis.com/maps/api/streetview/metadata?location=",
location, "&key=", Sys.getenv("GOOGLE_MAPS_API_KEY")
)
) %>% content("text"))
res$status == "OK"
},
latitude = {
if (valid) {
coords <- str_split(location, ",")[[1]]
res <- fromJSON(GET(
paste0(
"https://maps.googleapis.com/maps/api/streetview/metadata?location=",
location, "&key=", Sys.getenv("GOOGLE_MAPS_API_KEY")
)
) %>% content("text"))
res$location$lat
} else {
NA
}
},
longitude = {
if (valid) {
coords <- str_split(location, ",")[[1]]
res <- fromJSON(GET(
paste0(
"https://maps.googleapis.com/maps/api/streetview/metadata?location=",
location, "&key=", Sys.getenv("GOOGLE_MAPS_API_KEY")
)
) %>% content("text"))
res$location$lng
} else {
NA
}
}
) %>%
ungroup() %>%
filter(valid == TRUE)%>%
mutate(seqnum=row_number())%>%
filter(seqnum<=5)
if (nrow(locations) < 5) {
stop("Less than 5 valid locations found")
}
write_csv(locations, paste0(output_location,"Round ",round_no,"/locations.csv"))
# leaflet(locations) %>%
#   addProviderTiles(providers$CartoDB.Positron) %>%
#   addCircleMarkers(~longitude_draft, ~latitude_draft, fillColor = "blue", fillOpacity = 1, color = "black", stroke = TRUE,weight = 2, radius = 5, label = ~paste("Lat:", latitude_draft, "Lon:", longitude_draft)) %>%
#   addCircleMarkers(~longitude, ~latitude, fillColor = "red", fillOpacity = 1, color = "black", stroke = TRUE,weight = 2, radius = 5, label = ~paste("Exact Lat:", latitude, "Exact Lon:", longitude))
camera_angles<-c("0","72","144","216","288")
for (i in 1:nrow(locations)){
for (j in 1:length(camera_angles)){
# Parameters
api_key <- Sys.getenv("GOOGLE_MAPS_API_KEY")
location <- locations$location[i] # Latitude,Longitude
size <- "2048x2048"                 # Image size in pixels
heading <- camera_angles[j]                    # Direction of the camera in degrees
pitch <- "0"                      # Angle of the camera
output_file <- paste0(output_location,"Round ",round_no,"/location_",i,"_image_",j,".jpg")  # Name of the output file
# Construct the URL
url <- paste0(
"https://maps.googleapis.com/maps/api/streetview?",
"size=", size, "&",
"location=", location, "&",
"heading=", heading, "&",
"pitch=", pitch, "&",
"source=outdoor", "&",
"key=", api_key
)
# Download and save the image
response <- GET(url, write_disk(output_file, overwrite = TRUE))
# Check if the download was successful
if (response$status_code == 200) {
message("Image downloaded successfully!")
} else {
message("Failed to download image: ", response$status_code)
}
Sys.sleep(1)
}
}
if (pano=="on"){
for (i in 1:nrow(locations)){
file_paths <- c(paste0(output_location,"Round ",round_no,"/location_",i,"_image_1.jpg"),
paste0(output_location,"Round ",round_no,"/location_",i,"_image_2.jpg"),
paste0(output_location,"Round ",round_no,"/location_",i,"_image_3.jpg"),
paste0(output_location,"Round ",round_no,"/location_",i,"_image_4.jpg"),
paste0(output_location,"Round ",round_no,"/location_",i,"_image_5.jpg"))
images <- lapply(file_paths, image_read)
stitched_image <- image_append(image_join(images), stack = FALSE)
image_write(stitched_image, paste0(output_location,"Round ",round_no,"/location_",i,"_pano.jpg"))
}
}
library(tibble)
library(dplyr)
library(readr)
library(sf)
library(httr)
library(jsonlite)
library(purrr)
library(tidyverse)
library(janitor)
library(googlesheets4)
library(stringr)
library(geosphere)
library(leaflet)
library(magick)
library(metro)
library(gtfstools)
city <- "DC"        #DC or NYC
round_no <- 1
google_sheet_link<-"https://docs.google.com/spreadsheets/d/188wl-XhzJ0fz0TCU9zHMOKmARJes0_Is-VX1b9NZgAs/edit?usp=sharing"
pano<-"off" #on or off to save panorama pictures of locations
auto_run<-"yes"
at_large_percent<-1
downtown_percent<-0
greater_central_percent<-0
metro_percent<-0
manhattan_percent<-.45
brooklyn_percent<-.35
queens_percent<-.15
bronx_percent<-.05
subway_percent<-0
code_base<-paste0("C:/Users/jwest/github/geoguessr_cities/")
output_location<-paste0("C:/Users/jwest/github/geoguessr_cities/",city,"/output/")
if (auto_run=="yes"){
source(paste0(code_base,"01_borders.R"))
source(paste0(code_base,"02_locations.R"))
source(paste0(code_base,"03_metadata.R"))
source(paste0(code_base,"04_images.R"))
}
