)
# Download and save the image
response <- GET(url, write_disk(output_file, overwrite = TRUE))
# Check if the download was successful
if (response$status_code == 200) {
message("Image downloaded successfully!")
} else {
message("Failed to download image: ", response$status_code)
}
Sys.sleep(1)
}
}
library(dplyr)
library(tidyverse)
library(readr)
library(janitor)
library(googlesheets4)
library(stringr)
library(geosphere)
output_location<-"C:/Users/jwest/github/geoguessr_cities/DC/output/"
round_no<-1
answers<-read_csv(paste0(output_location,"Round ",round_no,"/locations.csv"))
guesses <- read_sheet("https://docs.google.com/spreadsheets/d/1FnSqet68G3hWA0wMUM0Ti-W-PRbS-DMRt4g8zYX5t5s/edit?usp=sharing", sheet=paste0("Sheet",round_no))%>%
clean_names()%>%
pivot_longer(cols = starts_with("guess_"),
names_to = "seqnum",
values_to = "link")%>%
mutate(seqnum=as.numeric(str_replace(seqnum,"guess_","")))
View(guesses)
guesses_processed<-guesses%>%
filter(!is.na(link))%>%
# mutate(location_guess = sub(".*!8m2!3d", "", link))%>%
# mutate(location_guess = sub("!16.*", "", location_guess))%>%
# mutate(location_guess = sub("!5m1.*", "", location_guess))%>%
# mutate(location_guess=str_replace(location_guess,"!4d",","))%>%
separate(location_guess, into = c("latitude_guess", "longitude_guess"), sep = ",", convert = TRUE)
guesses_processed<-guesses%>%
filter(!is.na(link))%>%
# mutate(location_guess = sub(".*!8m2!3d", "", link))%>%
# mutate(location_guess = sub("!16.*", "", location_guess))%>%
# mutate(location_guess = sub("!5m1.*", "", location_guess))%>%
# mutate(location_guess=str_replace(location_guess,"!4d",","))%>%
separate(guess, into = c("latitude_guess", "longitude_guess"), sep = ",", convert = TRUE)
guesses_processed<-guesses%>%
filter(!is.na(link))%>%
# mutate(location_guess = sub(".*!8m2!3d", "", link))%>%
# mutate(location_guess = sub("!16.*", "", location_guess))%>%
# mutate(location_guess = sub("!5m1.*", "", location_guess))%>%
# mutate(location_guess=str_replace(location_guess,"!4d",","))%>%
separate(link, into = c("latitude_guess", "longitude_guess"), sep = ",", convert = TRUE)
View(guesses_processed)
score_by_location<-answers%>%
right_join(guesses_processed,by=c("seqnum"))%>%
mutate(distance = distHaversine(cbind(longitude, latitude), cbind(longitude_guess, latitude_guess)) * 3.28084)%>%
mutate(score=round(5000 * exp(-10 * distance / 73000),0))
View(score_by_location)
score_by_team<-score_by_location%>%
group_by(team_name)%>%
summarise(score=sum(score,na.rm=T))
write_csv(score_by_location, paste0(output_location,"Round ",round_no,"/results by location.csv"))
write_csv(score_by_team, paste0(output_location,"Round ",round_no,"/results by team.csv"))
View(score_by_team)
library(leaflet)
library(dplyr)
library(tidyverse)
library(readr)
library(janitor)
library(googlesheets4)
library(stringr)
library(geosphere)
output_location<-"C:/Users/jwest/Documents/geoguessr_cities/DC/output/"
round_no<-1
score_by_location<-read_csv(paste0(output_location,"Round ",round_no,"/results by location.csv"))
seqnum_list <- unique(score_by_location$seqnum)
for (i in 1:length(seqnum_list)){
filtered_data <- score_by_location %>% filter(seqnum == seqnum_list[i])
# Create a leaflet map
map <- leaflet() %>%
addProviderTiles(providers$CartoDB.Positron)
# Add lines connecting each guess to its corresponding actual coordinate
for (i in 1:nrow(filtered_data)) {
map <- map %>%
addPolylines(
lng = c(filtered_data$longitude[i], filtered_data$longitude_guess[i]),
lat = c(filtered_data$latitude[i], filtered_data$latitude_guess[i]),
color = "black", opacity = 1, weight=1
)
}
# Add points for actual coordinates
map <- map %>%
addCircleMarkers(
data = filtered_data,
lng = ~longitude, lat = ~latitude,
color = "yellow", stroke = TRUE, weight = 4,
fillColor = "black", fillOpacity = 1, radius = 5,
popup = ~paste("Actual location ", max(filtered_data$seqnum))
)
# Add points for guessed coordinates
map <- map %>%
addCircleMarkers(
data = filtered_data,
lng = ~longitude_guess, lat = ~latitude_guess,
color = "black", stroke = TRUE, weight = 2,
fillColor = "red", fillOpacity = 1, radius = 5,
popup = ~paste(team_name,"\nScore: ",score)
)%>%
setView(lng = -77.0369, lat = 38.9072, zoom = 11)
# Render the map
print(max(filtered_data$seqnum))
print(map)
}
library(leaflet)
library(dplyr)
library(tidyverse)
library(readr)
library(janitor)
library(googlesheets4)
library(stringr)
library(geosphere)
output_location<-"C:/Users/jwest/github/geoguessr_cities/DC/output/"
round_no<-1
score_by_location<-read_csv(paste0(output_location,"Round ",round_no,"/results by location.csv"))
seqnum_list <- unique(score_by_location$seqnum)
for (i in 1:length(seqnum_list)){
filtered_data <- score_by_location %>% filter(seqnum == seqnum_list[i])
# Create a leaflet map
map <- leaflet() %>%
addProviderTiles(providers$CartoDB.Positron)
# Add lines connecting each guess to its corresponding actual coordinate
for (i in 1:nrow(filtered_data)) {
map <- map %>%
addPolylines(
lng = c(filtered_data$longitude[i], filtered_data$longitude_guess[i]),
lat = c(filtered_data$latitude[i], filtered_data$latitude_guess[i]),
color = "black", opacity = 1, weight=1
)
}
# Add points for actual coordinates
map <- map %>%
addCircleMarkers(
data = filtered_data,
lng = ~longitude, lat = ~latitude,
color = "yellow", stroke = TRUE, weight = 4,
fillColor = "black", fillOpacity = 1, radius = 5,
popup = ~paste("Actual location ", max(filtered_data$seqnum))
)
# Add points for guessed coordinates
map <- map %>%
addCircleMarkers(
data = filtered_data,
lng = ~longitude_guess, lat = ~latitude_guess,
color = "black", stroke = TRUE, weight = 2,
fillColor = "red", fillOpacity = 1, radius = 5,
popup = ~paste(team_name,"\nScore: ",score)
)%>%
setView(lng = -77.0369, lat = 38.9072, zoom = 11)
# Render the map
print(max(filtered_data$seqnum))
print(map)
}
library(tibble)
library(dplyr)
library(readr)
library(sf)
library(httr)
code_base<-"C:/Users/jwest/github/geoguessr_cities/DC"
output_location<-"C:/Users/jwest/github/geoguessr_cities/DC/output/"
round_no<-2
# Define the polygon using coordinates
polygon_coords <- matrix(c(
-77.119419, 38.934718,
-77.040882, 38.995841,
-76.909394, 38.892852,
-77.029331, 38.799234,
-77.027054, 38.855403,
-77.059426, 38.899524,
-77.119419, 38.934718 # Close the polygon
), ncol = 2, byrow = TRUE)
# Create an sf polygon
polygon_sf <- st_sfc(st_polygon(list(polygon_coords)), crs = 4326)
# Generate random points within the polygon
generate_random_points <- function(polygon, n = 1) {
bbox <- st_bbox(polygon)
points <- tibble(
lon = runif(n * 5, bbox["xmin"], bbox["xmax"]), # Generate extra points for filtering
lat = runif(n * 5, bbox["ymin"], bbox["ymax"])
) %>%
st_as_sf(coords = c("lon", "lat"), crs = 4326)
points_within <- points[st_intersects(points, polygon, sparse = FALSE), ]
if (nrow(points_within) < n) {
# Generate more points if needed
rbind(points_within, generate_random_points(polygon, n - nrow(points_within)))
} else {
points_within[1:n, ]
}
}
# Convert to dataframe with latitude and longitude
locations <- st_coordinates(generate_random_points(polygon_sf, n = 10)) %>%
as_tibble() %>%
rename(longitude = X, latitude = Y)%>%
mutate(location=paste0(latitude,",",longitude),
seqnum=row_number())
write_csv(locations, paste0(output_location,"Round ",round_no,"/locations.csv"))
camera_angles<-c("0","72","144","216","288")
for (i in 1:nrow(locations)){
for (j in 1:length(camera_angles)){
# Parameters
api_key <- Sys.getenv("GOOGLE_MAPS_API_KEY")
location <- locations$location[i] # Latitude,Longitude
size <- "2048x2048"                 # Image size in pixels
heading <- camera_angles[j]                    # Direction of the camera in degrees
pitch <- "0"                      # Angle of the camera
output_file <- paste0(output_location,"Round ",round_no,"/location_",i,"_image_",j,".jpg")  # Name of the output file
# Construct the URL
url <- paste0(
"https://maps.googleapis.com/maps/api/streetview?",
"size=", size, "&",
"location=", location, "&",
"heading=", heading, "&",
"pitch=", pitch, "&",
"key=", api_key
)
# Download and save the image
response <- GET(url, write_disk(output_file, overwrite = TRUE))
# Check if the download was successful
if (response$status_code == 200) {
message("Image downloaded successfully!")
} else {
message("Failed to download image: ", response$status_code)
}
Sys.sleep(1)
}
}
library(dplyr)
library(tidyverse)
library(readr)
library(janitor)
library(googlesheets4)
library(stringr)
library(geosphere)
output_location<-"C:/Users/jwest/github/geoguessr_cities/DC/output/"
round_no<-2
answers<-read_csv(paste0(output_location,"Round ",round_no,"/locations.csv"))
guesses <- read_sheet("https://docs.google.com/spreadsheets/d/1FnSqet68G3hWA0wMUM0Ti-W-PRbS-DMRt4g8zYX5t5s/edit?usp=sharing", sheet=paste0("Sheet",round_no))%>%
clean_names()%>%
pivot_longer(cols = starts_with("guess_"),
names_to = "seqnum",
values_to = "link")%>%
mutate(seqnum=as.numeric(str_replace(seqnum,"guess_","")))
guesses_processed<-guesses%>%
filter(!is.na(link))%>%
separate(link, into = c("latitude_guess", "longitude_guess"), sep = ",", convert = TRUE)
score_by_location<-answers%>%
right_join(guesses_processed,by=c("seqnum"))%>%
mutate(distance = distHaversine(cbind(longitude, latitude), cbind(longitude_guess, latitude_guess)) * 3.28084)%>%
mutate(score=round(5000 * exp(-10 * distance / 73000),0))
score_by_team<-score_by_location%>%
group_by(team_name)%>%
summarise(score=sum(score,na.rm=T))
write_csv(score_by_location, paste0(output_location,"Round ",round_no,"/results by location.csv"))
write_csv(score_by_team, paste0(output_location,"Round ",round_no,"/results by team.csv"))
View(score_by_location)
View(score_by_team)
library(leaflet)
library(dplyr)
library(tidyverse)
library(readr)
library(janitor)
library(googlesheets4)
library(stringr)
library(geosphere)
output_location<-"C:/Users/jwest/github/geoguessr_cities/DC/output/"
round_no<-1
score_by_location<-read_csv(paste0(output_location,"Round ",round_no,"/results by location.csv"))
seqnum_list <- unique(score_by_location$seqnum)
for (i in 1:length(seqnum_list)){
filtered_data <- score_by_location %>% filter(seqnum == seqnum_list[i])
# Create a leaflet map
map <- leaflet() %>%
addProviderTiles(providers$CartoDB.Positron)
# Add lines connecting each guess to its corresponding actual coordinate
for (i in 1:nrow(filtered_data)) {
map <- map %>%
addPolylines(
lng = c(filtered_data$longitude[i], filtered_data$longitude_guess[i]),
lat = c(filtered_data$latitude[i], filtered_data$latitude_guess[i]),
color = "black", opacity = 1, weight=1
)
}
# Add points for actual coordinates
map <- map %>%
addCircleMarkers(
data = filtered_data,
lng = ~longitude, lat = ~latitude,
color = "yellow", stroke = TRUE, weight = 4,
fillColor = "black", fillOpacity = 1, radius = 5,
popup = ~paste("Actual location ", max(filtered_data$seqnum))
)
# Add points for guessed coordinates
map <- map %>%
addCircleMarkers(
data = filtered_data,
lng = ~longitude_guess, lat = ~latitude_guess,
color = "black", stroke = TRUE, weight = 2,
fillColor = "red", fillOpacity = 1, radius = 5,
popup = ~paste(team_name,"\nScore: ",score)
)%>%
setView(lng = -77.0369, lat = 38.9072, zoom = 11)
# Render the map
print(max(filtered_data$seqnum))
print(map)
}
library(leaflet)
library(dplyr)
library(tidyverse)
library(readr)
library(janitor)
library(googlesheets4)
library(stringr)
library(geosphere)
output_location<-"C:/Users/jwest/github/geoguessr_cities/DC/output/"
round_no<-2
score_by_location<-read_csv(paste0(output_location,"Round ",round_no,"/results by location.csv"))
seqnum_list <- unique(score_by_location$seqnum)
for (i in 1:length(seqnum_list)){
filtered_data <- score_by_location %>% filter(seqnum == seqnum_list[i])
# Create a leaflet map
map <- leaflet() %>%
addProviderTiles(providers$CartoDB.Positron)
# Add lines connecting each guess to its corresponding actual coordinate
for (i in 1:nrow(filtered_data)) {
map <- map %>%
addPolylines(
lng = c(filtered_data$longitude[i], filtered_data$longitude_guess[i]),
lat = c(filtered_data$latitude[i], filtered_data$latitude_guess[i]),
color = "black", opacity = 1, weight=1
)
}
# Add points for actual coordinates
map <- map %>%
addCircleMarkers(
data = filtered_data,
lng = ~longitude, lat = ~latitude,
color = "yellow", stroke = TRUE, weight = 4,
fillColor = "black", fillOpacity = 1, radius = 5,
popup = ~paste("Actual location ", max(filtered_data$seqnum))
)
# Add points for guessed coordinates
map <- map %>%
addCircleMarkers(
data = filtered_data,
lng = ~longitude_guess, lat = ~latitude_guess,
color = "black", stroke = TRUE, weight = 2,
fillColor = "red", fillOpacity = 1, radius = 5,
popup = ~paste(team_name,"\nScore: ",score)
)%>%
setView(lng = -77.0369, lat = 38.9072, zoom = 11)
# Render the map
print(max(filtered_data$seqnum))
print(map)
}
library(tibble)
library(dplyr)
library(readr)
library(sf)
library(httr)
code_base<-"C:/Users/jwest/github/geoguessr_cities/DC"
output_location<-"C:/Users/jwest/github/geoguessr_cities/DC/output/"
round_no<-3
# Define the polygon using coordinates
polygon_coords <- matrix(c(
-77.119419, 38.934718,
-77.040882, 38.995841,
-76.909394, 38.892852,
-77.029331, 38.799234,
-77.027054, 38.855403,
-77.059426, 38.899524,
-77.119419, 38.934718 # Close the polygon
), ncol = 2, byrow = TRUE)
# Create an sf polygon
polygon_sf <- st_sfc(st_polygon(list(polygon_coords)), crs = 4326)
# Generate random points within the polygon
generate_random_points <- function(polygon, n = 1) {
bbox <- st_bbox(polygon)
points <- tibble(
lon = runif(n * 5, bbox["xmin"], bbox["xmax"]), # Generate extra points for filtering
lat = runif(n * 5, bbox["ymin"], bbox["ymax"])
) %>%
st_as_sf(coords = c("lon", "lat"), crs = 4326)
points_within <- points[st_intersects(points, polygon, sparse = FALSE), ]
if (nrow(points_within) < n) {
# Generate more points if needed
rbind(points_within, generate_random_points(polygon, n - nrow(points_within)))
} else {
points_within[1:n, ]
}
}
# Convert to dataframe with latitude and longitude
locations <- st_coordinates(generate_random_points(polygon_sf, n = 10)) %>%
as_tibble() %>%
rename(longitude = X, latitude = Y)%>%
mutate(location=paste0(latitude,",",longitude),
seqnum=row_number())
write_csv(locations, paste0(output_location,"Round ",round_no,"/locations.csv"))
camera_angles<-c("0","72","144","216","288")
for (i in 1:nrow(locations)){
for (j in 1:length(camera_angles)){
# Parameters
api_key <- Sys.getenv("GOOGLE_MAPS_API_KEY")
location <- locations$location[i] # Latitude,Longitude
size <- "2048x2048"                 # Image size in pixels
heading <- camera_angles[j]                    # Direction of the camera in degrees
pitch <- "0"                      # Angle of the camera
output_file <- paste0(output_location,"Round ",round_no,"/location_",i,"_image_",j,".jpg")  # Name of the output file
# Construct the URL
url <- paste0(
"https://maps.googleapis.com/maps/api/streetview?",
"size=", size, "&",
"location=", location, "&",
"heading=", heading, "&",
"pitch=", pitch, "&",
"key=", api_key
)
# Download and save the image
response <- GET(url, write_disk(output_file, overwrite = TRUE))
# Check if the download was successful
if (response$status_code == 200) {
message("Image downloaded successfully!")
} else {
message("Failed to download image: ", response$status_code)
}
Sys.sleep(1)
}
}
library(dplyr)
library(tidyverse)
library(readr)
library(janitor)
library(googlesheets4)
library(stringr)
library(geosphere)
output_location<-"C:/Users/jwest/github/geoguessr_cities/DC/output/"
round_no<-3
answers<-read_csv(paste0(output_location,"Round ",round_no,"/locations.csv"))
guesses <- read_sheet("https://docs.google.com/spreadsheets/d/1FnSqet68G3hWA0wMUM0Ti-W-PRbS-DMRt4g8zYX5t5s/edit?usp=sharing", sheet=paste0("Sheet",round_no))%>%
clean_names()%>%
pivot_longer(cols = starts_with("guess_"),
names_to = "seqnum",
values_to = "link")%>%
mutate(seqnum=as.numeric(str_replace(seqnum,"guess_","")))
guesses_processed<-guesses%>%
filter(!is.na(link))%>%
separate(link, into = c("latitude_guess", "longitude_guess"), sep = ",", convert = TRUE)
score_by_location<-answers%>%
right_join(guesses_processed,by=c("seqnum"))%>%
mutate(distance = distHaversine(cbind(longitude, latitude), cbind(longitude_guess, latitude_guess)) * 3.28084)%>%
mutate(score=round(5000 * exp(-10 * distance / 73000),0))
score_by_team<-score_by_location%>%
group_by(team_name)%>%
summarise(score=sum(score,na.rm=T))
write_csv(score_by_location, paste0(output_location,"Round ",round_no,"/results by location.csv"))
write_csv(score_by_team, paste0(output_location,"Round ",round_no,"/results by team.csv"))
View(score_by_location)
library(leaflet)
library(dplyr)
library(tidyverse)
library(readr)
library(janitor)
library(googlesheets4)
library(stringr)
library(geosphere)
output_location<-"C:/Users/jwest/github/geoguessr_cities/DC/output/"
round_no<-3
score_by_location<-read_csv(paste0(output_location,"Round ",round_no,"/results by location.csv"))
seqnum_list <- unique(score_by_location$seqnum)
for (i in 1:length(seqnum_list)){
filtered_data <- score_by_location %>% filter(seqnum == seqnum_list[i])
# Create a leaflet map
map <- leaflet() %>%
addProviderTiles(providers$CartoDB.Positron)
# Add lines connecting each guess to its corresponding actual coordinate
for (i in 1:nrow(filtered_data)) {
map <- map %>%
addPolylines(
lng = c(filtered_data$longitude[i], filtered_data$longitude_guess[i]),
lat = c(filtered_data$latitude[i], filtered_data$latitude_guess[i]),
color = "black", opacity = 1, weight=1
)
}
# Add points for actual coordinates
map <- map %>%
addCircleMarkers(
data = filtered_data,
lng = ~longitude, lat = ~latitude,
color = "yellow", stroke = TRUE, weight = 4,
fillColor = "black", fillOpacity = 1, radius = 5,
popup = ~paste("Actual location ", max(filtered_data$seqnum))
)
# Add points for guessed coordinates
map <- map %>%
addCircleMarkers(
data = filtered_data,
lng = ~longitude_guess, lat = ~latitude_guess,
color = "black", stroke = TRUE, weight = 2,
fillColor = "red", fillOpacity = 1, radius = 5,
popup = ~paste(team_name,"\nScore: ",score)
)%>%
setView(lng = -77.0369, lat = 38.9072, zoom = 11)
# Render the map
print(max(filtered_data$seqnum))
print(map)
}
